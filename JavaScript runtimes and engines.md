# Множество, множество, множество JavaScript-рантаймов последнего десятилетия


За последнее десятилетие нас накрыла настоящая лавина новых JavaScript-рантаймов (и в равной степени — движков), позволяющих запускать JavaScript в самых разных контекстах с точным соответствием задаче. Благодаря им мы увидели, как язык распространился в облака, на edge-устройства, Smart TV, мобильные девайсы и даже микроконтроллеры.

В этой статье мы исследуем, что движет этим разнообразием, и почему ни один рантайм или движок не подходит для всех целей.

## Edge-вычисления

Первое потребительское решение для «edge-вычислений» было представлено еще в 2002 году компанией Akamai, которая позволила разрабатывать на edge с использованием [Java и .NET](https://www.akamai.com/blog/news/20-years-of-edge-computing). Но пройдет много времени, прежде чем JavaScript присоединится к этим языкам — с одной стороны, JavaScript не стал бы полезным как серверный язык до появления Node.js в 2009 году, а с другой — Node.js не использовался бы в бессерверном контексте до появления [AWS Lambda](https://aws.amazon.com/blogs/aws/run-code-cloud/) в 2014 году. Лишь с анонсом Lambda@Edge (в превью [с декабря 2016 года](https://aws.amazon.com/blogs/aws/coming-soon-lambda-at-the-edge/); выпущен [в марте 2017](https://hidekazu-konishi.com/entry/aws_history_and_timeline_amazon_lambda.html)) JavaScript наконец-то увидели на edge, снова работающим на Node.js.

Но монополии Amazon было суждено продлиться недолго. Всего через шесть месяцев состоялся [релиз](https://blog.cloudflare.com/introducing-cloudflare-workers) Cloudflare Workers — минималистичного рантайма, purpose-built построенного вокруг [Service Worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) API. Он был разработан, чтобы открыть для Cloudflare «[совершенно новый рынок](https://www.sec.gov/Archives/edgar/data/1477333/000119312519222176/d735023ds1.htm#:~:text=This%20opens%20up%20an%20entirely%20new%20market%20for%20us%3A%20compute%20and%20storage.)»: вычисления и хранение данных. И это было заметно иным начинанием, чем у Amazon — впервые за более чем двадцать лет с момента появления JavaScript компании удалось напрямую коммерциализировать JavaScript-рантайм.

Cloudflare Workers добился феноменального успеха: [миллиарды задач](https://www.cloudflare.com/en-gb/press-releases/2018/cloudflare-workers-opens-edge-computing-to-everyone/) были выполнены в течение полугода после его бета-релиза. Этот запах возможностей спровоцировал золотую лихорадку. Вскоре после этого, в 2018 году, [появился Deno](https://www.youtube.com/watch?v=M3BM9TB-8yA) как претендент на смену Node.js, и уже через три года была образована [Deno Land Inc](https://deno.com/blog/the-deno-company), запустившая Deno Deploy — edge-сеть, призванную составить [конкуренцию](https://tinyclouds.org/javascript_containers) Cloudflare. С первоначальным капиталом в 4,9 миллиона долларов и привлечением раунда финансирования Series A в 21 миллион долларов годом позже, становится ясно, что не только Cloudflare верили в ценность этой ниши.

Лихорадка продолжилась в 2022 году. Едва был сформирован [WinterCG](https://wintercg.org/) для [определения](https://deno.com/blog/announcing-wintercg) общей основы всех этих новых появляющихся JavaScript-рантаймов, как появился [Bun](https://bun.sh/), быстро привлекший 7 миллионов долларов [архив](https://web.archive.org/web/20230810132129/https://oven.sh/blog/bun-funding), чтобы предоставить бессерверный хостинг, непрерывную интеграцию и… edge-вычисления. Wasmer последовал их примеру в 2023 году, вступив на арену Service Workers с [WinterJS](https://wasmer.io/posts/announcing-winterjs-service-workers) и [Wasmer Edge](https://wasmer.io/posts/announcing-wasmer-edge). И чтобы не отставать, уже в следующем году AWS ответила с [LLRT](https://news.ycombinator.com/item?id=39304188) — еще одним рантаймом с низкой задержкой, как раз подходящим для edge (хотя и без предложения для edge-воркеров на тот момент).

При всем стратегическом сходстве примечательно разнообразие движков, лежащих в основе всех этих рантаймов. В то время как Deno и CloudFlare Workers (которые работают на рантайме [`workerd`](https://github.com/cloudflare/workerd/tree/main)) продолжают традицию Node.js по использованию [V8](https://v8.dev/), мы видим, что Bun использует [JavaScriptCore](https://docs.webkit.org/Deep%20Dive/JSC/JavaScriptCore.html), WinterJS — [SpiderMonkey](https://spidermonkey.dev/), а LLRT — [QuickJS](https://github.com/quickjs-ng/quickjs). Бэкенд больше не является исключительно сценой для Node.js и V8 — теперь стало модно выбирать рантайм и движок, оптимизированные под конкретную задачу.

### Микроконтроллеры

Многие из вышеперечисленных рантаймов с трудом бы запустились на микроконтроллере. Для тех, кто не знаком с ними, AWS даёт следующее определение:

> … микроконтроллер — это базовый вычислительный блок внутри умных электронных устройств, таких как стиральные машины и термостаты. Это очень маленький компьютер с собственной оперативной памятью (RAM), постоянной памятью (ROM) и системами ввода-вывода (I/O), всё встроено в один чип. Он может обрабатывать цифровые сигналы и реагировать на пользовательский ввод, но его вычислительные возможности ограничены.

На нижнем конце спектра микроконтроллеры могут стоить всего 3 цента, иметь всего несколько байт оперативной памяти, работать при токе менее миллиампера, иметь 8-битную архитектуру и/или иметь менее килобайта памяти.

Учитывая эти характеристики, полноценный Node.js совершенно не подходит, поэтому многие взялись за создание максимально slim-движков — [Duktape](https://duktape.org/), [Espruino](https://www.espruino.com/), и [mjs](https://github.com/cesanta/mjs) в 2013 году, [JerryScript](https://jerryscript.net/) в 2014, [Moddable](https://www.moddable.com/) в 2018, и [elk](https://github.com/cesanta/elk) в 2021. Эти проекты гордятся тем, что работают при менее чем 64 КБ оперативной памяти (на самом деле, по-видимому, немногим более 100 байт в случае Elk!), хотя и идут на компромиссы в других областях, таких как производительность, чтобы достичь этого.

Эти движки, в свою очередь, породили новые рантаймы, хотя и не обязательно предназначенные для самых слабых микроконтроллеров. JerryScript лежит в основе [IoT.js](https://iotjs.net/) (2015) и [Microlattice.js](https://github.com/workshop/microlattice) (2016) — обоих рантаймов для Интернета вещей; [XS](https://github.com/Moddable-OpenSource/moddable/blob/public/documentation/xs/XS%20Overview.md) (2018?) лежит в основе Moddable; а DukTape лежит в основе [low.js](http://www.lowjs.org/) (2018) — низкоресурсной реимплементации Node.js.

Это показывает, что венчурный капитал не обязательно должен быть приманкой для разработки JavaScript-рантайма; иногда люди просто хотят запускать JavaScript на устройстве, несмотря ни на что. А иногда они хотят вызывать JavaScript, даже работая на другом языке, — что подводит нас к следующей теме.

>_От автора данного курса: 
>Хочу ещё добавить, что есть даже рантайм для моделирования печатных плат на React.JS [tscircuit](https://docs.tscircuit.com/)_

### Полиглотные движки

Хотя большинство JavaScript-движков основаны на собственной виртуальной машине (VM), используемой только ими самими, некоторые основаны на established VM, что обеспечивает межъязыковое взаимодействие (interop) с нулевой стоимостью. В этом пространстве C++ не обязательно является королём, и интересно наблюдать, сколькими способами можно написать JavaScript-движок.

Самым ранним полиглотным движком был [Rhino](https://github.com/mozilla/rhino), созданный в 1997 году как попытка написать Netscape Navigator — включая движок JavaScript — полностью на Java. Rhino поддерживает двунаправленное взаимодействие между Java и JavaScript, работая на основе JVM. Это значит, что он позволяет JavaScript реализовывать Java-интерфейсы и вызывать методы Java-классов, в то же время позволяя Java определять JavaScript-классы, запускать скрипты и многое другое. К 2006 году он был включён в JDK 6, а к 2008 году стал основой рантайма [Helma](https://ringojs.org/), ныне известного как RingoJS.

Однако в JDK 8 (2014) его сменил [Nashorn](https://openjdk.org/projects/nashorn/), которого, в свою очередь, в JDK 11 сменил [Graal.js](https://www.graalvm.org/latest/reference-manual/js/) (2018), поддерживающий как JVM, так и GraalVM. Это интересная линия истории, поскольку — все будучи проектами Mozilla или Oracle — эти три движка, возможно, являются единственными JavaScript-рантаймами, имеющими законное право использовать товарный знак JavaScript (в ожидании исхода спора [Deno vs. Oracle](https://deno.com/blog/deno-v-oracle)). Однако Graal.js по праву занимает своё место наверху, заходя так далеко, что поддерживает весь Node.js SDK благодаря встраиванию всей его кодовой базы.

Но эта линия — лишь верхушка айсберга. Существует [jint](https://github.com/sebastienros/jint) (2013) для .NET, написанный на C#. Существуют [PyNarcissus](https://github.com/nathanhi/py-narcissus) (2009), [langjs](https://github.com/laverdet/langjs) (2009) и [jispy](https://github.com/jaredly/jispy) (2014) для Python. Существуют [twostroke](https://github.com/drbig/twostroke) (2011) и [Opal](https://opalrb.com/) (2013) для Ruby. Существует [elsa](https://github.com/elsaland/elsa) (2020) для Go. Существуют [Boa](https://github.com/boa-dev/boa) (2018), [toyjs](https://github.com/0xabad1dea/toyjs) (2020), [rquickjs](https://github.com/DelSkayn/rquickjs) (2020), [spiderfire](https://github.com/3cpx/spiderfire) (2021), [Nova](https://github.com/risc0/nova) (2022) и [jaws](https://github.com/maximecb/jaws) (2024) для Rust. Существует [Kiesel](https://github.com/kiesel-rs/kiesel) (2023) для Zig, и этот список наверняка продолжается. Хотя, строго говоря, не все эти проекты полностью «полиглотны» — некоторые являются merely интерпретаторами и не предлагают двунаправленного межъязыкового взаимодействия.

JavaScript-движки даже реализуются на самом JavaScript! [Narcissus](https://github.com/mozilla/narcissus) (2007-2010), изначально созданный Бренданом Айком, использовался Mozilla в качестве испытательного стенда для быстрого прототипирования новых функций языка JavaScript. За ним последовал [Jscomp](https://github.com/mozilla-spidermonkey/jsparagus/blob/master/jscomp.md) в 2015 году — AoT-компилятор, написанный на JavaScript, который генерировал исполняемый код на C++. Совсем недавно Оливер Медхёрст подхватил эстафету с [Porffor](https://porffor.com/) (2023), компилируя вместо этого в WASM (или, как дополнительный шаг, в C). Он продолжает дело его equally примечательного веб-движка [Shadow](https://github.com/Oliver-Mead/shadow) (2023), similarly написанного на JavaScript. Хотя начиналось это как хобби-проект, Porffor показал такую ценность, что привлёк финансовую поддержку от Криса Ванстрата, позволившую Оливеру работать над ним на полную ставку с 2024 года, что привело к 58% прохождению тестов Test262 менее чем через год.

Этот спрос на вызов JavaScript из других языков и даже создание новых JavaScript-движков на нём самом подчёркивает силу его экосистемы и эргономику языка. Хотя нигде это преимущество экосистемы не проявляется так ясно, как в мире нативных приложений.

### Нативные приложения

Веб-происхождение JavaScript делает его языком, хорошо подходящим для создания GUI-приложений, поэтому было лишь вопросом времени, когда его начнут использовать в нативных приложениях, часто в качестве основы для кроссплатформенных фреймворков. Постоянным предметом споров в этом пространстве является вопрос о том, какой баланс найти между верностью веб-платформе и верности нативной платформе. Так с чего же лучше начать, как не с фреймворков, которые сделали полную ставку на веб?

#### Приложения на основе WebView

##### На мобильных устройствах
Релиз iPhone в 2007 году установил новую планку для мобильного железа, нормализовав использование десктопных веб-технологий на мобильных устройствах. Но с тем, что iOS, Android, Windows Phone, Blackberry, WebOS, Symbian, Samsung Bada и Firefox OS одновременно боролись за долю рынка, разработка только под одну платформу представляла собой значительные альтернативные издержки. В 2009 году Adobe ответила на эту дилемму, выпустив [PhoneGap](https://phonegap.com/) — фреймворк для встраивания веб-приложений в нативные приложения через «web view» (который, конечно, включал JavaScript-рантайм).

PhoneGap доказал свою популярность: к 2011 году на его сервисе сборки было создано более 23 000 приложений (согласно [противоречивому графику](https://web.archive.org/web/20111130022538/http://phonegap.com/2011/11/21/phonegap-and-the-enterprise/)), а к 2012 году он был «загружен более 1 миллиона раз» и «использовался более 400 000 разработчиками» ([источник](https://web.archive.org/web/20120509041542/http://phonegap.com/2012/04/12/phonegap-is-now-a-part-of-adobe/)). По пути он был открыт под именем [Cordova](https://cordova.apache.org/), и для него был создан UI-тулкит — [Ionic](https://ionicframework.com/). Команда behind Ionic впоследствии, в 2019 году, анонсировала [преемника](https://ionic.io/blog/announcing-capacitor-1-0) для Cordova, [Capacitor](https://capacitorjs.com/), который принёс улучшенный API для нативных плагинов и добавил поддержку десктопов через другой набирающий популярность фреймворк, Electron.

##### На десктопах
[Electron](https://www.electronjs.org/), теперь household name для разработки десктопных приложений на основе WebView, прослеживает свои корни до [node-webkit](https://github.com/nwjs/nw.js), проекта, релизы которого датируются аж 2012 годом. В то время как последний изначально был основан на Node.js и WebKit, в 2015 году он был переименован в [NW.js](https://nwjs.io/) из-за планов миграции на Chromium (усилие, которое было завершено с v0.13.0 в 2016 году). История Electron идёт параллельно: в 2013 году GitHub начала работу над [Atom Shell](https://github.com/electron/electron), фреймворком, похожим на NW.js, built бывшим core-контрибьютором NW.js для использования в качестве основы их текстового редактора Atom. Хотя сам Atom однажды будет заморожен, Atom Shell проживёт дальше, будучи переименованным в Electron в 2015 году. Хотя NW.js — активный проект по сей день, Electron очень much взял на себя роль главного героя, придя к доминированию на рынке десктопных приложений, причём многие ведущие в отрасли приложения, такие как Discord, Slack, Linear и Visual Studio Code, основаны на нём.

##### На Smart TV
Помимо мобильных и десктопов, существует также экзотическая платформа Smart TV. Многие Smart TV работают на форках десктопных веб-браузеров с дополнительными API для взаимодействия с нативной функциональностью TV, такой как broadcast stream, object carousel, наборы клавиш пульта дистанционного управления и системы DRM.

Веб-ориентированные спецификации/платформы для Smart TV включают OIPF (2008-2015), [HbbTV](https://hbbtv.org/) (2010 — настоящее время) и [ATSC 3.0](https://www.atsc.org/nextgen-tv/) (2016 — настоящее время). Также есть бесчисленное множество платформ с разными SDK, таких как webOS, YouView, Freeview Play, Freesat и другие. На некоторых платформах вы договариваетесь с провайдером инфраструктуры о трансляции приложения; на других — с владельцем платформы о распространении приложения с устройствами; а на третьих (например, платформы на основе Android TV и Apple TV) вы отправляете приложение в app store.

Популярные Amazon Fire TV (2014) и Fire TV Stick (2014) основаны на Chromium, как и телевизоры Samsung Tizen с 2017 года (до этого использовался WebKit), и все они используют Cordova, что показывает, что он не только для мобильных устройств. Roku отличается тем, что приложения программируются на BrightScript (не на языке ECMAScript). И хотя Apple TV раньше предлагала фреймворк, известный как [TVMLKit JS](https://developer.apple.com/documentation/tvmlkit) (2015), основанный на JavaScriptCore, он не был основан на веб-технологиях, за исключением реализации очень небольшой части спецификации DOM.

При том, что в мире установлено более 1,26 миллиарда интернет-подключённых TV-устройств, а устройства HbbTV присутствуют более чем в 100 миллионах домов только в Европе, Smart TV составляют удивительно большой сегмент JavaScript-рантаймов. Только благодаря этому общему языку и вездесущей веб-платформе практично развёртывать приложения на огромном количестве различных типов устройств на этом рынке.

### React Native

#### На мобильных устройствах
Когда мобильный ландшафт начал стабилизироваться, сократившись в основном до iOS и Android, Facebook анонсировал в 2015 году новый кроссплатформенный фреймворк, нацеленный на обе эти платформы: [React Native](https://reactnative.dev/). Этот фреймворк позволил разработчикам писать React-приложение, которое рендерило бы нативные view платформы, на основе JavaScript-рантайма, который мог вызывать нативную функциональность и реагировать на нативные события через отправку сериализуемых сообщений через «мост» (bridge).

Изначально этот JavaScript-рантайм был основан на JavaScriptCore, так как он входил в iOS SDK (и делал это начиная с iOS 7 в 2013 году) и, таким образом, значительно экономил размер приложения для пользователей iOS. Будучи также сильно оптимизированным для мобильного использования, это был разумный выбор на тот момент. Однако после нескольких лет наблюдений за его работой на практике Facebook захотел его улучшить — и поэтому в 2019 году они анонсировали [Hermes](https://hermesengine.dev/), новый движок, созданный специально для React Native.

Hermes мог похвастаться улучшенным временем запуска благодаря различным трюкам, таким как компиляция [Ahead of Time (AoT)](https://engineering.fb.com/2019/07/12/android/hermes/) (обходившая запрет Apple на JIT) и [memory mapping](https://github.com/facebook/hermes/issues/907#issuecomment-1411144097) своего байткода в RAM. Он также сокращал размер бандла для Android (где JavaScriptCore не является системным фреймворком) и использование памяти для обеих платформ. Hermes настолько хорошо оправдал ожидания, что стал вариантом по умолчанию с 2022 года, и Meta даже готовит преемника, [Static Hermes](https://github.com/facebook/hermes/blob/main/doc/StaticHermes.md) (2023), который будет поддерживать произвольное сочетание нативного и интерпретируемого кода, как «типизированного», так и «нетипизированного», чтобы обеспечить производительность на уровне C/C++.

Однако Hermes был не единственным изученным вариантом. С 2018 года React Native начал реализовывать [движко-независимый JavaScript Interface (JSI)](https://reactnative.dev/architecture/jsi), который (помимо отказа от отправки сообщений в пользу прямых нативных биндингов) позволил адаптировать его для использования с различными движками. JSI был реализован для Hermes и JSC (оба — Meta), V8 (независимо Microsoft и Expo; см. [доклад Кудо Чиена](https://www.youtube.com/watch?v=uHwgjfCwyU0) о последнем), QuickJS (Microsoft, для хакатона), Chakra (Microsoft, для использования в React Native Windows, так как Chakra поставляется с Windows) и даже [Duktape](https://github.com/semmypurewal/react-native-duktape) (от Семми Пьюуэла)!

Фактически, React Native, похоже, станет самым движко-независимым JavaScript-рантаймом из всех, поскольку Microsoft, Callstack и сообщество React Native ([включая меня](https://buttondown.com/whatever_jamie)!) в настоящее время усердно работают над реализацией поддержки [Node-API](https://nodejs.org/api/n-api.html), который поддерживается ещё шире, чем JSI (об этом позже). Учитывая также интероп с нативным кодом первого класса, обещанный с приходом Static Hermes, он прошёл долгий путь от своих истоков как рантайм с одним движком и передачей сообщений.

Но насколько он популярен по сравнению с фреймворками для разработки приложений на основе WebView? [Эван Бэкон](https://evanbacon.dev/) [сообщил](https://x.com/Baconbrix/status/1732804060346368289), что к 2023 году только 74 из 2479 лучших iOS-приложений использовали либо Cordova, либо Capacitor, причём большинство всё ещё использовало только первый. В то время как к 2025 году 30 из 100 лучших iOS-приложений были написаны на React Native по сравнению всего с 3 приложениями, ориентированными на WebView. RevenueCat (лидирующее решение для In-App Purchases, используемое более чем 50 000 приложений), [сообщает](https://www.revenuecat.com/blog/react-native-popularity), что React Native «на пути» к тому, чтобы стать самым популярным фреймворком для разработки приложений, использующих их платформу: 34% приложений, использующих RevenueCat, основаны на нём, а на фреймворки типа Cordova приходится менее 1%.

#### На десктопах
Однако для десктопных платформ история совсем другая. Хотя Microsoft поддерживает полнофункциональные реализации React Native для [macOS](https://microsoft.github.io/react-native-windows/docs/rnw-macos-getting-started) и [Windows](https://microsoft.github.io/react-native-windows/) (независимые от [реализации ptmt для macOS](https://github.com/ptmt/react-native-macos) 2015 года), экосистема для этих платформ составляет лишь малую долю от той, что есть для iOS и Android: всего 20 нативных модулей в [React Native Directory](https://reactnative.directory/) указывают поддержку десктопа по сравнению с 1698 для мобильных на момент написания. Это отражается на меньшей пользовательской базе: только около 100 респондентов в [опросе State of React Native 2024](https://www.jetbrains.com/lp/rn-survey-2024/) указали десктоп в качестве цели против более 3000, указавших мобильные устройства.

Рекомендуемый мета-фреймворк для использования React Native, [Expo](https://expo.dev/), до сих пор не поддерживает десктоп, и хотя Microsoft использовала React Native в различных приложениях Office и даже в меню «Пуск», в основном это решение для brownfield-разработки, создающее небольшие островки контента внутри приложений. Для greenfield-приложений Electron гораздо более в моде, только в их [галерее](https://www.electronjs.org/apps) перечислены сотни приложений.

Предпринимались некоторые попытки нацелиться на Linux, такие как [React Native Linux](https://github.com/canonical/react-native-desktop) (Qt-форк от Canonical, позже переименованный в React Native Desktop) (2017-2021) и [React Native Skia](https://shopify.github.io/react-native-skia/) (2020), но ни один из них не получил широкого распространения: последний использовался всего 20 респондентами в упомянутом опросе. Опять же, предположительно, здесь доминирующим инструментом является Electron.

#### На Smart TV
Однако React Native имеет значительные позиции в пространстве Smart TV: реализации для [tvOS](https://reactnative.dev/docs/out-of-tree-platforms#apple-tv) (2016) и [Android TV](https://reactnative.dev/docs/out-of-tree-platforms#android-tv) (2018) пользуются популярностью. С упадком You.i TV (чей проприетарный You.i Engine One развертывался на 14 различных платформах), лидерами в этом пространстве теперь являются [Callstack](https://callstack.com/), развертывающие на similarly большом стабиле платформ. Примечательные приложения на React Native включают Crunchyroll, NFL, Bloomberg, Yahoo Finance и многие другие.

### NativeScript

Вовсе не было так, что нативные приложения были гонкой только между Cordova и React Native. [NativeScript](https://nativescript.org/), анонсированный в 2014 году, вышел на рынок, предлагая три отдельных рантайма с полными JavaScript-привязками (bindings) к платформам iOS, Android и Universal Windows (через JavaScriptCore, V8 и снова V8 соответственно), абстрагированные кроссплатформенным фреймворком для разработки приложений. Хотя упадок Windows Phone привёл к прекращению поддержки рантайма для Windows в 2016 году, рантаймы для iOS и Android продолжают существовать по сей день, перейдя на стандартизацию на V8 в 2019 году (по сути, как только V8 начал поддерживать режим без JIT, чтобы enable его использование в App Store). И хотя рантайм для tvOS, показанный как proof-of-concept в 2015 году, так и не взлетел, рантаймы для [Android Wear](https://www.nativescript.org/blog/a-first-look-at-nativescript-for-android-wear) (2015) и [Android TV](https://www.nativescript.org/blog/announcing-the-nativescript-android-tv-runtime) (2018) нашли применение в индустрии.

В последнее время NativeScript усилил фокус на том, чтобы позволить использовать рантаймы standalone (а не как часть end-to-end фреймворка для разработки приложений), переработав рантаймы в движко-независимые библиотеки JS↔нативных привязок через [Node-API](https://nodejs.org/api/n-api.html). Эти новые библиотеки для [iOS](https://github.com/NativeScript/ns-ios-node-api) (2023) и [Android](https://github.com/NativeScript/ns-android-node-api) (2024) могут «улучшить» любой JavaScript-движок, предоставив ему полный доступ к платформе, при условии, что движок поддерживает Node-API, а список таких движков довольно длинный. Действительно, Node-API был реализован для V8 (от Node.js, Deno и ByteDance), JSC (от Bun, Hummer и ByteDance), Hermes (от Microsoft и Hummer), QuickJS (от OpenHarmony, Hummer и ByteDance), Chakra (от node-chakracore) и JerryScript (от IoT.js).

Хотя ни одно из 100 лучших iOS-приложений сегодня не использует NativeScript, новая реархитектура на основе Node-API позволит ему интегрироваться с более доминирующими фреймворками, такими как React Native и Electron, решая боли доступа к нативным API, подобно интеграции с (до-Node-API) Capacitor в 2021 году. Proof-of-concept интеграция с [Expo](https://github.com/NativeScript/friendly-node-api-targets/tree/main/packages/expo) (моя работа!) продемонстрировала это в 2024 году, однако работа продолжается, чтобы позволить использовать её без патчинга и форкинга.

### Node.js

В то время как упомянутые выше рантаймы являются частью end-to-end (и обычно кроссплатформенного) фреймворка для разработки приложений, Node.js в нативных приложениях в основном использовался лишь как инструмент для доступа к Node.js SDK и/или нативным аддонам, не добившись особого успеха в создании графических пользовательских интерфейсов.

Потребовалось почти десятилетие после его релиза, чтобы Node.js был портирован на мобильные устройства — работа, которую предприняла [Janea Systems](https://janeasystems.com/) в 2017 году. Одним из основных препятствий для развертывания на iOS было то, что App Store не разрешал приложения, использующие JIT-компиляцию. Janea Systems обошли это, создав форк [Node-ChakraCore](https://github.com/nodejs/node-chakracore), проекта Microsoft, который заменил V8 на ChakraCore для работы без JIT. Это было модно в то время: [SpiderNode](https://github.com/mozilla/spidernode) (2017) adopted SpiderMonkey, [node-jsc](https://github.com/deviceplane/node-jsc) (2018) adopted JavaScriptCore (что привело к появлению [node-native-script](https://github.com/deviceplane/node-native-script) в том же году, [демо](https://www.youtube.com/watch?v=z_7t8k9fL_c)), и [node-jerryscript](https://github.com/jerryscript-project/node-jerryscript) (2019) adopted JerryScript.

В конечном итоге Janea Systems смогли перейти на V8, как только режим без JIT распространился из V8 в 2019 году в Node.js в 2020 году. Хотя они демонстрировали использование Node.js вместе с React Native еще в 2017 году, это никогда по-настоящему не прижилось для этого use-case, и Node.js для мобильных устройств оставался второстепенным игроком в мобильной разработке. Однако он продолжает использоваться, и эстафета перешла от Janea Systems к новому форку от [Андре Стальца](https://github.com/staltz/mobile-node) в 2023 году.

Помимо порта от Janea Systems, Samsung создала свой собственный [Lightweight Node.js](https://github.com/Samsung/LightweightNode.js) (2021) на основе своего более раннего движка [Escargot](https://github.com/Samsung/escargot) (2016) для «устройств среднего класса, таких как мобильные телефоны, планшеты и телевизоры», который, вероятно, используется в [Tizen OS](https://www.tizen.org/), хотя проект, возможно, не находит большого применения за пределами Samsung.

На стороне десктопов существовало бесчисленное количество библиотек для предоставления доступа к функциональности разработки нативных приложений через Node.js. Для macOS AppKit были, например, [NodObjC](https://github.com/TooTallNate/NodObjC) (2011), [objc](https://github.com/lukehedger/objc) (2017) и [NativeScript](https://nativescript.org/) (2023). Для WinRT был [NodeRT](https://github.com/NodeRT/NodeRT) (2014) (которому вторил основанный на Deno [deno_winrt](https://github.com/littledivy/deno_winrt) в 2023 году). А для Qt были [nodeQt](https://github.com/arturadib/node-qt) (2011), [node-qt](https://github.com/mika-finen/node-qt) (2012) и [NodeGUI](https://nodegui.org/) (2019). Несмотря на предоставление полного доступа к платформе, ни один из них не стал популярным как end-to-end решение для разработки приложений, конкурентоспособное с Electron.

### Резюме

JavaScript оседлал волну бума персональных устройств, как никакой другой язык программирования. Хотя стремление вырваться из браузера для полного использования нативных API было мотивацией, ни одному фреймворку не удалось полностью отойти от условностей веб-платформы: программирование GUI по-прежнему прочно вдохновлено API браузера (как в React Native), если не полностью делегировано WebView (как в Electron).

### Заключение

Разработчики хотят запускать JavaScript в любом возможном контексте, и за последние десять лет они устремились к этой цели. Раньше язык был ограничен браузером, а теперь его можно встретить практически в каждой категории устройств, и — в бессерверных контекстах — люди даже платят за его выполнение.

JavaScript-рантаймы существуют, чтобы удовлетворять всевозможные ограничения по ресурсам — от самых дешёвых чипов до самых мощных машин (хотя, возможно, с меньшим проникновением в суперкомпьютеры, которые не упоминались в этом исследовании). Существуют отличные варианты для взаимодействия с другими языками, часто для облегчения доступа к системным API (чем активно пользуются такие фреймворки, как React Native).

Наконец, JavaScript продолжает демонстрировать свою силу как язык для программирования GUI, используясь самыми разными способами для разработки нативных приложений на мобильных телефонах и Smart TV, хотя на десктопе по-прежнему в моде приложения на основе WebView.

Так почему же не существует одного «лучшего» рантайма? Просто из-за огромного количества различных контекстов, в которых нужно запускать JavaScript, существует слишком много конфликтующих факторов для оптимизации. Скорость запуска, производительность во время выполнения, размер бандла, поддержка API и простота доступа к нативному функционалу — всё это борется за приоритет. Хотя движки из браузерного мира, V8 и JavaScriptCore, сохранили свою популярность и за его пределами, они начинают сталкиваться с конкуренцией со стороны рантаймов на основе новых движков, таких как Hermes и QuickJS, в определённых областях.

Но здоровая конкуренция и свобода выбора — это всегда хорошо. Старая гвардия вынуждена развиваться, а для новичков поддерживается высокий стандарт. Для разработчиков это самый универсальный язык, который можно выучить, и самый безопасный технологический выбор на будущее.

### Послесловие

Я начал писать эту статью в апреле 2024 года, растянув лимиты истории редактирования Buttondown до более чем 5260 правок к августу, прежде чем продолжил периодически возиться с ней ещё 12 месяцев. Даже сейчас я вряд ли могу назвать её законченной. Я хотел осветить тему по справедливости, но материала просто слишком много, и мне бы наконец хотелось опубликовать это, чтобы я мог написать что-то ещё. Наверняка можно сказать гораздо больше о WebAssembly, эмуляторах, носимых устройствах и рантаймах для игр (с добавлением ActionScript?), но давайте пока оставим этот ящик Пандоры закрытым.

В процессе написания вышло несколько новых рантаймов. Наиболее примечательно, что ByteDance анонсировала кроссплатформенный фреймворк [Lynx](https://lynx.bytedance.net/) (2025), чей (одноимённый) рантайм основан на их новом движке PrimJS (самом, в свою очередь, основанном на QuickJS). У меня не было времени разобраться в нём, но могу сказать, что меня fascinates, что рантайм дополнительно поддерживает JavaScriptCore, QuickJS и V8 через Node-API. Любопытно, что пока на Android по умолчанию используется PrimJS повсеместно, на iOS по умолчанию используется смесь PrimJS на основном потоке и JavaScriptCore на фоновом. Это делает его довольно необычным явлением среди всех остальных рассмотренных выше рантаймов.

И, слишком сосредоточившись на небраузерных контекстах, я, к своему смущению, похоже, упустил [LibWeb](https://github.com/SerenityOS/serenity/tree/master/Userland/Libraries/LibWeb), браузерный движок (включая JavaScript-рантайм), основанный на движке LibJS из набирающего популярность браузера [Ladybird](https://ladybird.org/) (2020), за которым я пристально слежу.

Кроме того, у меня есть список упоминаний почёта, которые я просто не сумел вплести в повествование (хотя некоторые, по общему признанию, выходят за границы «последнего десятилетия»). А именно:

*   **[gjs](https://gitlab.gnome.org/GNOME/gjs)** (2008): JavaScript-рантайм на основе SpiderMonkey с привязками к GNOME.
*   **[MuJS](https://mujs.com/)** (2013): Высоко-встраиваемый JavaScript-движок.
*   **[JavaScript for Automation (JXA)](https://web.archive.org/web/20240523064153/https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/Introduction.html)** (2014): JavaScript-рантайм от Apple на основе JavaScriptCore, который включает полную JavaScript-проекцию для (основанного на Objective-C) macOS SDK.
*   **[dukluv](https://github.com/creationix/dukluv)** (2014): JavaScript-рантайм на основе libuv, использующий движок Duktape.
*   **[Napa.js](https://github.com/microsoft/napajs)** (2016): Многопоточный JavaScript-рантайм, построенный на V8.
*   **[txiki.js](https://github.com/saghul/txiki.js)** (2019): JavaScript-рантайм на основе libuv, использующий движок QuickJS (преемник dukluv).
*   **[Bare](https://barejs.com/)** (2022): Небольшой и модульный JavaScript-рантайм для десктопов и мобильных устройств.
*   **[lo.js](https://github.com/just-js/lo)** (2023): Я не совсем понимаю, что это за JavaScript-рантайм, но я постоянно слышу о его невероятном интеропе с C.
*   ... и наверняка есть много других, которые заслуживают упоминания!

На этой ноте спасибо за чтение! Я надеюсь, что эта статья повысит осведомлённость о JavaScript-рантаймах за пределами привычного нарратива «браузеры и Node.js» и начнёт передавать истинный масштаб айсберга.

Если вам показалось, что это было чертовски хорошее чтение, то отличная новость заключается в том, что ниже есть механизм, чтобы получать его больше. Скорее всего, увидимся в следующем выпуске, где я снова буду говорить о Whatever.

Ещё раз, ссылка на оригинал статьи [The many, many, many JavaScript runtimes of the last decade](https://buttondown.com/whatever_jamie/archive/the-many-many-many-javascript-runtimes-of-the-last-decade/). Также советую посмотреть [комментарии Theo Browne](https://youtu.be/WM1R3kS01NA?si=S7uTbX9o8qeuooaH) к этой статье.


